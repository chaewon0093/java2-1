# 202330137 백채원

## java2-1
개요는 리드미에 나온다

## 3월 15일 강의
내용정리

## 3월 22일 강의
자바의 특성
1. 플랫폼 독립성
하드웨어, 운영체제에 종속되지 않는 바이트 코드로 플랫폼 독립성
2. 객체지향
캡슐화, 상속, 다형성 지원
3. 클래스로 캡슐화
자바의 모든 변수나 함수는 클래스 내에 선언, 클래스 안에서 클래스(내부 클래스 작성 가능)

소스(.java)와 클래스(.class)파일
1. 하나의 소스 파일에 여러 클래스 작성 가능(public 클래스는 하나만 가능)
2. 소스 파일의 이름과 public으로 선언도니 클래스 이름은 같아야 함
3. 클래스 파일에는 하나의 클래스만 존재(다수의 클래스를 가진 자바 소스를 컴파일하면 클래스마다 별도 클래스 파일 생성)

자바의 특징(2)
  실행코드 배포
구성
- 한 개의 class 파일 또는 다수의 파일로 구성
- 여러 폴더에 걸쳐 다수의 클래스 파일로 구성된 경우:jar 압축 파일로 배포
자바 응용프로그램의 실행은 main() 메소드에서 시작
- 하나의 클래스 파일에 두 개 이상의 main() 메소드가 있을 수 없음

자바의 특징(3)
실시간 응용 프로그램에 부적합
- 실행 도중 예측할 수 없는 기점에 가비지 컬렉션 실행 때문
자바 프로그램은 안전
- 타임 체크 엄격
물리적 주소를 사용하는 포인터 개념 없음
프로그램 작성 쉬움
- 포인터 개념이 없음
- 물리적 주소를 사용하는 포인터 개념 없음
프로그램 작성 쉬움
- 포인터 개념이 없음
- 동적 메모리 반환 하지 않음
- 다양한 라이브러리 지원
실행 속도 개선을 위한 JIT 컴파일러 사용
- 자바는 바이트 코드를 인터프리터 방식으로 실행(기계어가 실행되는 것보다 느림)
- JIT 컴파일 기법으로 실행 속도 개선(JIT 컴파일-실행 중에 바이트 코드를  기계어 코드로 컴파일하여 기계어를 실행하는 기법)


## 3월 29일 강의
자바의 키 입력과 System.in

System.in
- 키보드와 연결된 자바의 표준 입력 스트림
- 입력되는 키를 바이트(문자 아님)로 리턴하는 저수준 스트림
- System.in을 직접 사용하면 바이트를 문자나 숫자로 변환하는 많은 어려움 있음

Scanner를 이용한 키 입력
Scanner는 입력되는 키 값을 공백으로 구분되는 토큰 단위로 읽음
- 개발자가 원하는 타입 값으로 쉽게 읽을 수 있음

반복문
자바 반복문 - for 문, while 문, do-while 문
for 문 - 가장 많이 사용하는 반복문

중첩 반복
반복문이 또다른 반복문을 내포하고 있는 것


## 4월 5일 강의
배열 리언
배열의 레퍼런스만 리턴(배열 전체가 리턴되는 것이 아님)

메소드의 리턴 타입
리턴하는 배열의 타입과 리턴 받는 배열 타입 일치
리턴 타입에 배열의 크기를 지정하지 않음

예외(Exception)
- 실행 중 오동작이나 결과에 악영향을 미치는 예상치 못한 상황 발생
자바에서는 실행 중 발생하는 에러를 예외로 처리
- 실행 중 예외가 발생하면
자바 플랫폼은 응용프로그램이 예외를 처리하도록 호출
응용프로그램이 예외를 처리하지 않으면 프로그램 강제 종료 시킴
- 예외 발생 경우
정수를 0으로 나누는 겨웅
배열의 크기보다 큰 인덱스로 배열의 원소를 접근하는 경우
정수를 읽는 코드가 실행되고 있을 때 사용자가 문자를 입력한 경우

캡슐화
객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것
객체의 가장 본질적인 특징은 외부의 접근으로부터 객체 보호
* 쉽게 생각하자면 붕어빵 생각하면 됌 !!
캡슐 = 붕어빵 껍데기, 객체 = 팔

자바의 캡슐화 
클래스(class):객체 모양을 선언한 틀(캡슐화 하는 틀)

자바의 객체 지향 특성
상속
상위 개체의 속성이 하위 개체에 물려짐
하위 개체가 상위 개체의 속성을 모두 가지는 관계

자바 상속
상의 클래스의 멤버를 하위 클래스가 물려받음
상위 클래스:슈퍼 클래스, 하위 클래스:서브 클래스(슈퍼 클래스 코드의 재사용, 새로운 특성 추가 가능)

객체 지향 언어의 목적
소프트웨어의 생산성 향상
컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기(life cycle) 단축
소프트웨어를 빠른 속도로 생산한 필요성 증대

객체 지향 언어
- 상속, 다형성, 객체, 캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장
- 소프트웨어 재사용과 부분 수정 빠름
- 소프트웨어를 다시 만드는 부담 대폭 줄임
- 소프트웨어 생산성 향상

실세계에 대한 쉬운 모델링
- 초기 프로그래밍
수학 계산/통계 처리를 하는 등 처리 과정, 계산 절차 중요

- 현대 프로그래밍
컴퓨터가 산업 발전에 활용
실세계에서 발생하는 일을 프로그래밍
실세계에서는 절차나 과정보가 물체(객체)들의 상호 작용으로 묘사하는 것이 용이

- 객체 지향 언어
실세계의 일을 보다 쉽게 프로그래밍하기 위한 객체 중심적 언어

절차 지향 프로그래밍
작업 순서를 표현하는 컴퓨터 명령 집합
함수들의 집합으로 프로그램 작성
객체 지향 프로그래밍
컴퓨터가 수행하는 작업을 객체들간의 상호 작용으로 표현
클래스 혹은 객체들의 집합으로 프로그램 작성


클래스
객체의 속성(state)과 행위(behavior) 선언
객체의 설계도 혹은 틀

객체
클래스의 틀로 찍어낸 실체
- 프로그램 실행 중에 생성되는 실체 
- 메모리 공간을 갖는 구체적인 실체
- 인스턴스(instance)라고도 부름

자바 클래스 구성
클래스 
class 키워드로 선언
멤버 : 클래스 구성 요소
필드(멤버 변수)와 메소드(멤버 함수)
클래스에 대한 public 접근 지정:다른 모든 클래스에서 클래스 사용 허락
멤버에 대한 public 접근 지정 : 다른 모든 클래스에게 멤버 접근 허용

메소드
메소드는 C/C++의 함수와 동일
자바의 모든 메소드는 반드시 클래스 안에 있어야 함(캡슐화 원칙)

접근 지정자
- 다른 클래스에서 메소드를 접근할 수 있는지 여부 선언
- public, private, protected, 디폴트(접근 지정자 생략)
리턴 타입
메소드가 리턴하는 값의 데이터 타입

객체 소멸
- new에 의해 할당 받은 객체와 배열 메모리를 자바 가상 기계로 되돌려 주는 행위
- 소멸된 객체 공간은 가용 메모리에 포함

자바에서 사용자 임의로 객체 소멸 안됨
자바는 객체 소멸 연산자 없음
객체 생성 연산자:new
객체 소멸은 자바 가상 기계의 고유한 역할
자바 개발자에게는 매우 다행스러운 기능
C/C++에서는 할당 받은 객체를 개발자가 프로그램 내에서 삭제해야 함
C/C++의 프로그램 작성을 어렵게 만드는 요인
자바에서는 사용하지 않는 객체나 배열을 돌려주는 코딩 책임으로부터 개발자 해방


접근 지정자
자바의 접근 지정자
4가지
- private, protected, public, 티폴트(접근지정자 생략)

접근 지정자의 목적
클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용
객체 지향 언어의 캡슐화 정책은 멤버를 보호하는 것
접근 지정은 캡슐화에 묶인 보호를 일부 해제할 목적

클래스 접근 지정
다른 클래스에서 사용하도록 허용할 지 지정
public 클래스
다른 모든 클래스에게 접근 허용
디폴트 클래스(접근지정자 생략)
package-private라고도 함
같은 패키지의 클래스에만 접근 허용

## 04월 12일 강의
static 멤버의 생성
static 멤버는 클래스당 하나만 생성
객체들에 의해 공유됨



static 멤버 사용
- 클래스 이름으로 접근 가능
- 객체의 멤버로 접근 가능
- non-static 멤버는 클래스 이름으로 접근 안됨

final 클래스와 메소드
final 클래스 - 더 이상 클래스 상속 불가능
final 메소드 - 더 이상 오버라이딩 불가능


슈퍼 클래스의 멤버에 대한 서브 클래스의 접근
 
슈퍼 클래스의 private 멤버
- 서브 클래스에서 접근할 수 없음

슈퍼 클래스의 디폴트 멤버
- 서브 클래스가 동일한 패키지에 있을 때, 접근 가능

슈퍼 클래스의 public 멤버
- 서브 클래스는 항상 접근 가능

슈퍼 클래스의 protected 멤버
- 같은 패키지 내의 모든 클래스 접근 허용


protected 멤버
protected 멤버에 대한 접근
같은 패키지의 모든 클래스에게 허용
상속되는 서브 클래스(같은 패키지든 다른 페키지든 상관 없음)에게 허용

업캐스팅
기본 클래스의 포인터로 파생 클래스의 객체를 가리키는 것
한 곳을 가리키면 다른 곳은 가리킬 수 없다
- 서브 클래스의 레퍼런스를 슈퍼 클래스 레퍼런스에 대입
- 슈퍼 클래스 레퍼런스로 서브 클래스 객체를 가리키게 되는 현상 * 슈퍼클래스 레퍼런스로 객체 내의 슈퍼 클래스의 멤버만 접근 가능

다운캐스팅
- 슈퍼 클래스 레퍼런스를 서브 클래스 레퍼런스에 대입
- 업캐스팅된 것을 다시 원래대로 되돌리는 것
- 반드시 명시적 타입 변환 지정
업캐스팅 레퍼런스로는 객체의 실제 타입을 구분하기 어려움

instanceof 연산자
레퍼런스가 가리키는 객체의 타입 식별
객체레퍼런스 instanceof 클래스타입

서브 클래스 객체와 오버라이딩 된 메소드 호출
- 오버라이딩한 메소드가 실행됨을 보장


추상 클래스
추상 메소드
abstract로 선언된 메소드, 메소드의 코드는 없고 원형만 선언

추상 클래스
추상 메소드를 가지며, abstract로 선언된 클래스
추상 메소드 없이, abstract로 선언한 클래스


## 04월 19일 강의
추상 클래스의 상속과 구현
추상 클래스 상속
- 추상 클래스를 상속 받으면 추상 클래스가 됨

추상 클래스의 목적
- 상속을 위한 슈퍼 클래스로 활용하는 것
- 서브 클래스에서 추상 메소드 구현
- 다형성 실현

자바의 인터페이스
- 클래스가 구현해야 할 메소드들이 선언되는 추상형
- 인터페이스 선언(interface 키워드로 선언)  
자바 인터페이스에 대한 변화  
- java 7까지(인터페이스는 상수)
- java 8부터(상수와 추상메소드 포함, default, private, static 메소드 포함)  
여전히 인터페이스에는 필드(멤버 변수) 선언 불가  

인터페이스 간에 상속 가능  
인터페이스를 상속해 확장된 인터페이스 작성 가능  
extends 키워드로 상속 선언  
  
### 자바의 패키지와 모듈이란?  
패키지(package)  
서로 관련된 클래스와 인터페이스를 컴파일한 클래스 파일들을 묶어 놓은 디렉터리  
하나의 응용프로그램은 한 개 이상의 패키지로 작성  
패키지는 jar 파일로 압축 가능  
모듈(module)  
여러 패키지와 이미지 등의 자원을 모아 높은 컨테이너  
Java 9부터 모듈화 도입  
플랫폼의 모듈화 
Java 9부터 자바 API의 모든 클래스들(자바 실행 환경)을 패키지 기반에서 모듈들로 완전히 재구성  
응용프로그램의 모듈화  
- 클래스들은 패키지로 만들고, 다시 패키지를 모듈로 많듦
- 모듈 프로그래밍은 어렵고 복잡, 기존 방식으로 프로그램 작성  
  

모듈화의 목적  
Java 9부터 자바 API를 여러 모듈(99개)로 분할  
- Java 8까지는 rt.jar의 한 파일에 모든 API 저장  
  
응용프로그램이 실행할 때 꼭 필요한 모듈들로만 실행 환경 구축  
- 메모리 자원이 열악한 작은 소형 기기에 꼭 필요한 모듈로 구성된 작은 크기의 실행 이미지를 만들기 위함  
  
모듈의 현실  
- Java 9부터 전면적으로 도입
- 복잡한 개념
- 큰 자바 응용프로그램에는 개발, 유지보수 등에 적합
- 현실적으로 모듈로 나누어 자바 프로그램을 작성할 필요 없음  
  
다른 패키지에 작성된 클래스 사용  
import를 이용하지 않는 경우  
- 소스에 클래스 이름의 완전 경로명 사용  
  
필요한 클래스만 import  
- 소스 시작 부분에 클래스의 경로명 import  
- import 패키지.클래스
- 소스에는 클래스 명 명시하면 됨
- 
## 05월 03일 강의
컬렉션  
요소라고 불리는 가변 개수의 객체들의 저장소
- 객체들의 컨테이너라고도 불림
- 요소의 개수에 따라 크기 자동 조절

컬렉션은 제너릭 기법으로 구현
      
제네릭  
- 특정 타입만 다루지 않고, 여러 종류의 타입으로 변신할 수 있도록 클래스나
메소드를 일반화시키는 기법
제네릭 컬렉션 사례:벡터
- <E>에서 E에 구체적인 타입을 주어 구체적인 타입만 다루는 벡터로 활용
- 정수만 다루는 컬렉션 벡터 Vector<Integer>
- 문자열만 다루는 컬렉션 벡터 Vector<String>

컬렉션의 요소는 객체만 가능
- int, char, double 등의 기본 타입으로 구체화 불가

벡터 Vector<E>의 특성
- <E>에 사용할 요소의 특정 타입으로 구체화
- 배열을 가변 크기로 다룰 수 있게 하는 컨테이너
  - 배열의 길이 제한 극복
  - 요소의 개수가 넘치면 자동으로 길이 조절
- 요소 객체들을 삽입, 삭제, 검색하는 컨테이너
  - 삽입, 삭제에 따라 자동으로 요소의 위치 조정


HashMap<K, V>
키(key)와 값(value)의 쌍으로 구성되는 요소를 다루는 컬렉션  
- K:키로 사용할 요소의 타입
- V:값으로 사용할 요소의 타입
- '값'을 검색하기 위해서는 반드시 '키' 사용

삽입 및 검색이 빠른 특징
- 요소 삽입:put() 메소드
- 요소 검색:get() 메소드

컨테이너와 컴포넌트
컨테이너  
- 다른 컴퓨넌트를 포함할 수 있는 GUI 컴포넌트
  - java.awt.Container를 상속받음
- 다른 컨테이너에 포함될 수 있음
  - AWT 컨테이너 : Panel, Frame, Applet, Dialog, Window
  - Swing 컨테이너 : JPanel JFrame, JApplet, JDialog, JWindow

컴포넌트  
- 컨테이너에 포함되어야 화면에 출력될 수 있는 GUI 객체
- 다른 컴포넌트를 포함할 수 없는 순수 컴포넌트
- 모든 GUI 컴포넌트가 상속받는 클래스 : java.awt.Component
- 스윙 컴포넌트가 상속받는 클래스 : javax.swing.JComponent

최상위 컨테이너
- 다른 컨테이너에 포함되지 않고도 화면에 출력되며 독립적으로 존재 가능한 컨테이너
  - 스스로 화면에 자신을 출력하는 컨테이너 : JFrame, JDialog, JApplet


## 05월 17일
배치 관리자 대표 유형 4가지  
FlowLayout 배치관리자  
- 컴포넌트가 삽입되는 순서대로 왼쪽에서 오른쪽으로 배치  
- 배치할 공간이 없으면 아래로 내려와서 반복한다. 
   
BorderLayout 배치관리자  
- 컨테이너의 공간을 동, 서, 남, 북, 중앙의 5개 영역으로 나눔
  
GridLayout 배치관리자  
- 컨테이너를 프로그램에서 설정한 동일한 크기의 2차원 격자로 나눔
- 컴포넌트는 삽입 순서대로 좌에서 우로, 다시 위에서 아래로 배치
  
CardLayout  
- 컨테이너의 공간에 카드를 쌓아놓은 듯이 컴포넌트를 포개어 배치


스윙 응용프로그램의 종료
응용프로그램 내에서 스스로 종료하는 방법  
System.exit(0);  
언제 어디서나 무조건 종료  
  
프레임의 오른쪽 상단의 종료버튼(X)이 클릭되면 어떤 일이 일어나는가?  
프레임 종료, 프레임 윈도우를 닫음(프레임이 화면에서 보이지 않게 됨)  
프레임이 보이지 않게 되지만 응용프로그램이 종료한 것은 아님(키보드나 마우스 입력을 받지 못함, 다시 setVisible(true))를 호출하면, 보이게 되고 이전 처럼 작동함  

프레임 종료버튼이 클릭될 때, 프레임과 함께 프로그램을 종료시키는 방법  
frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    
  
BorderLayout 생성자와 add()메소드  
생성자  
- BorderLayout()
- BorderLayout(int hGap, int yGap)  
  - hGap(좌우 두 컴포텉트 사이의 수평 간격, 픽셀 단위, 디폴트:0)
  - yGap(상하 두 컴포넌트 사이의 수직 간격, 픽셀 단위, 디폴트:0)  
    
add()메소드  
- void add(Componenet comp, int index)
  - comp 컴포넌트를 index 위치에 삽입한다.
  - index : 컴포넌트의 위치  
  동:BorderLayout.EAST, 서:BorderLayout.WEST, 남:borderLayout.SOUTH, 북:BorderLayout.NORTH, 중앙:BorderLayout.CENTER  

